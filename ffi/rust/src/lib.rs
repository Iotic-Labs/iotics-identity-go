//! Foreign Function Interface  library utilising "wrapped"
//! [iotics-identity-go](../../../../../README.md).
//!
//! [`ffi_wrapper`] is automatically generated by
//! [`rust-bindgen`](https://docs.rs/bindgen/)
//! during the build.

use std::ffi::{CStr, CString, NulError};
use std::str::Utf8Error;

use thiserror::Error;

#[allow(
    non_camel_case_types,
    non_upper_case_globals,
    improper_ctypes,
    non_snake_case,
    clippy::missing_safety_doc,
    clippy::redundant_static_lifetimes
)]
pub mod ffi_wrapper;

/// Struct containing all the required secrets and parameters for working with this library.
#[derive(Debug, Clone)]
pub struct Config {
    pub resolver_address: String,
    pub user_did: String,
    pub agent_did: String,
    pub agent_key_name: String,
    pub agent_name: String,
    pub agent_secret: String,
    pub token_duration: i64,
}

/// A common error type used across this library.
#[derive(Error, Debug)]
pub enum IdentityLibError {
    #[error(transparent)]
    Utf8Error(#[from] Utf8Error),
    #[error(transparent)]
    NulError(#[from] NulError),
    #[error("FFI library error message: `{0}`.")]
    Message(String),
}

impl Drop for ffi_wrapper::CreateAgentAuthToken_return {
    fn drop(&mut self) {
        unsafe {
            ffi_wrapper::FreeUpCString(self.r0);
            ffi_wrapper::FreeUpCString(self.r1);
        }
    }
}

impl Drop for ffi_wrapper::CreateTwinDidWithControlDelegation_return {
    fn drop(&mut self) {
        unsafe {
            ffi_wrapper::FreeUpCString(self.r0);
            ffi_wrapper::FreeUpCString(self.r1);
        }
    }
}

/// Gets an authentication token used for connecting with the IOTICSpace.
///
/// Params:
/// - [`config`][Config] - Struct containing all the required secrets and parameters for working with this library.
///
/// Returns:
/// - [`Result`][Result::Ok] with [`String`] if generating a token success.
/// - [`Result`][Result::Err] with [`IdentityLibError`] if generating a token fails.
pub fn create_agent_auth_token(config: &Config) -> Result<String, IdentityLibError> {
    let result = unsafe {
        ffi_wrapper::CreateAgentAuthToken(
            go_string(&CString::new(config.agent_did.as_str())?),
            go_string(&CString::new(config.agent_key_name.as_str())?),
            go_string(&CString::new(config.agent_name.as_str())?),
            go_string(&CString::new(config.agent_secret.as_str())?),
            go_string(&CString::new(config.user_did.as_str())?),
            config.token_duration,
        )
    };
    let token = unsafe { CStr::from_ptr(result.r0) }.to_str()?;
    let error = unsafe { CStr::from_ptr(result.r1) }.to_str()?;

    match error.is_empty() {
        true => Ok(token.to_string()),
        false => Err(IdentityLibError::Message(error.to_string())),
    }
}

/// Gets a twin DID that can be used for creating a real twin in the IOTICSpace.
///
/// Params:
/// - [`config`][Config] - Struct containing all the required secrets and parameters for working with this library.
/// - [`twin_key_name`][`str`] - Used to create a new (or regenerate already existing one) DID.
/// - [`twin_name`][`str`] - Will show up in the public document. Not used as part of the DID hash.
///
/// Returns:
/// - [`Result`][Result::Ok] with [`String`] if generating a DID success.
/// - [`Result`][Result::Err] with [`IdentityLibError`] if generating a DID fails.
pub fn create_twin_did_with_control_delegation(
    config: &Config,
    twin_key_name: &str,
    twin_name: &str,
) -> Result<String, IdentityLibError> {
    let result = unsafe {
        ffi_wrapper::CreateTwinDidWithControlDelegation(
            go_string(&CString::new(config.resolver_address.as_str())?),
            go_string(&CString::new(config.agent_did.as_str())?),
            go_string(&CString::new(config.agent_key_name.as_str())?),
            go_string(&CString::new(config.agent_name.as_str())?),
            go_string(&CString::new(config.agent_secret.as_str())?),
            go_string(&CString::new(twin_key_name)?),
            go_string(&CString::new(twin_name)?),
        )
    };

    let twin_did = unsafe { CStr::from_ptr(result.r0) }.to_str()?;
    let error = unsafe { CStr::from_ptr(result.r1) }.to_str()?;

    match error.is_empty() {
        true => Ok(twin_did.to_string()),
        false => Err(IdentityLibError::Message(error.to_string())),
    }
}

/// Helper returning string type compatible with FFI Go counterpart.
fn go_string(c_string: &CString) -> ffi_wrapper::GoString {
    ffi_wrapper::GoString {
        p: c_string.as_ptr(),
        n: c_string.as_bytes().len() as isize,
    }
}
